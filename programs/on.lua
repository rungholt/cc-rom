--[[ Get with
  pastebin get W4GLNE39 on
 or
  std pb W4GLNE39 on
  std ld on on

  Aren't I great with names??
--]]

local rebootCompsAtStart = false
--Set the above variable to true if you want On to reboot all PCs at startup.

local configFile = "/.on_conf"

local tArg = {...}
if tArg[1] == "rmconf" then
	fs.delete(configFile)
end

if tArg[1] == "conf" then
	return shell.run("edit " .. configFile)
end


local compNames = {}
local compIDs = {}
local names = peripheral.getNames()

local function loadConfig()
	if fs.exists(configFile) == false then
		file = fs.open(configFile, "w")
		file.writeLine("background = false")
		file.writeLine("onOrOff = 'on'")
		file.writeLine("animations = true")
		file.writeLine("spoofMode = false")
		file.writeLine("loadBarChar = '@'")
		file.writeLine("compList = '/.complist'")
		file.writeLine("monitorTextScale = 0.5")
		file.writeLine("startupProg = nil")
		file.close()
	end
	
	dofile(configFile)
end

local function writeCompFileList()
	file = fs.open(compList, "w")
	file.writeLine("List of last connected computers. Do not modify.")
	for a = 1, #compNames do
		if compNames[a] ~= nil and compIDs[a] ~= nil then
			file.writeLine("  '" .. compNames[a] .. "', id:" .. compIDs[a])
		end
	end
	file.writeLine("\nFile generated by On by LDDestroier/EldidiStroyrr (same guy).")
	file.close()
end

local function loadAnimaion()
	screenX, screenY = term.getSize()
	ani_spinLine = {
		".",
		"|",
		"|",
		"|",
		"|",
		" "
	}
	ani_loadBar = {  --I'm sure there's a better way of doing this, but it's not to my knowledge.
		"[      ]",
		"[" .. loadBarChar.. "     ]",
		"[" .. string.rep(loadBarChar, 2) .. "    ]",
		"[" .. string.rep(loadBarChar, 3) .. "   ]",
		"[ " .. string.rep(loadBarChar, 3) .. "  ]",
		"[  " .. string.rep(loadBarChar, 3) .. " ]",
		"[   " .. string.rep(loadBarChar, 3) .. "]",
		"[    " .. string.rep(loadBarChar, 2) .. "]",
		"[     " .. loadBarChar.. "]",
		"[      ]",
		"[      ]"
	}
end

local function getBGColors() --I was getting used to the nomenclature
	if background == false then
		if colormode then
			term.setBackgroundColor(128)
		else
			term.setBackgroundColor(1)
		end
	else
		term.setBackgroundColor(colors.black)
	end
end

local sides = {"right", "left", "top", "bottom", "front", "back"}

local function getConfig()
	local names = peripheral.getNames()
	local isOpen = false
	for k,v in pairs(sides) do
	        if peripheral.getType(v)=="modem" then
	                rednet.open(v)
	                isOpen=true
	        end
	end
	
	if term.isColor then  --Gotta make sure that normal computers aren't using colors!
		if term.isColor() then
			colormode = true
		else
			colormode = false
		end
	end

	loadAnimaion()
	
	getBGColors()

	scr_x, scr_y = term.getSize()
	itemThreshold = scr_y - 5
end

loadConfig()

getConfig()

for a = 1, #sides do
	if peripheral.getType(sides[a]) == "monitor" then
		local mon = peripheral.wrap(sides[a])
		mon.setTextScale(monitorTextScale)
	end
end

function round(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

function getDefaultColors()
	if colormode and background == false then
		term.setTextColor(16)
	else
		term.setTextColor(colors.black)
	end
end

function getCompNames() --Simply gets all computer names and puts them into a table and a readable text file.
	compNames = {}
	compIDs = {}
	names = peripheral.getNames()
	for a = 1, #names do
		if string.find(names[a], "computer") then
			local c = peripheral.wrap(names[a])
			if c ~= nil then
				table.insert(compNames, names[a])
				table.insert(compIDs, c.getID())
			end
		end
	end
	if spoofMode then
		table.insert(compNames, "computer_test1")
		table.insert(compIDs, 1)
		table.insert(compNames, "computer_test2")
		table.insert(compIDs, 2)
		table.insert(compNames, "computer_test3")
		table.insert(compIDs, 5)
		table.insert(compNames, "computer_test4")
		table.insert(compIDs, 4)
	end
end

local itemX, itemY, itemPosXes, itemPosYes, scrollOver, doesntFit

local function printCompNames() --Prints all output to screen.
	term.clear()
	term.setCursorPos(1,1)
	if background == false then
		getDefaultColors()
	end
	if onOrOff == "on" then
		write("Comps On'd:")
	elseif onOrOff == "off" then
		write("Comps Off'd:")
	end
	write(" (" .. #compNames .. ")\n")

	itemX = 1
	itemY = 2

	itemPosXes = {}
	itemPosYes = {}

	scrollOver = 0
	doesntFit = false

	for a = 1, #compNames do
		term.setCursorPos(itemX,itemY)
		if compNames[a] ~= nil and compIDs[a] ~= nil then
			if itemX <= 8 then
				if itemY >= itemThreshold then
					itemX = itemX + 25
					itemY = 1
				else
					itemY = itemY + 1
				end
			else
				if itemY >= scr_y - 1 then
					itemX = itemX + 25
					itemY = 1
					scrollOver = scrollOver + 1
				else
					itemY = itemY + 1
				end
			end
			posX, posY = term.getCursorPos()
			scr_x, scr_y = term.getSize()
			if scr_x - posX >= 25 then
				write(" " .. compNames[a])
				write(" (id:" .. compIDs[a] .. ")")
				posX, posY = term.getCursorPos()
				table.insert(itemPosXes, posX)
				table.insert(itemPosYes, posY)
			else
				msg = "Screen is too small to list all computers"
				local messageX = scr_x - string.len(msg)
				term.setCursorPos(messageX,scr_y)
				write(msg)
				getDefaultColors()
				getBGColors()
				break
			end
		end
	end
	local menuY = scr_y - 3
	term.setCursorPos(1,menuY)
	print("'R': reboot all")
	print("'B': run in background")
	print("'X': exit")
	writeCompFileList()
	maximumItems = itemThreshold + (scr_y * scrollOver)
end

local function turnCompsOn()
	for a = 1, #compNames do
		c = peripheral.wrap(compNames[a])
		if c ~= nil then
			if onOrOff == "on" then
				c.turnOn()
			elseif onOrOff == "off" then
				c.shutdown()
			else
				error("'onOrOff' is neither \"on\" or \"off\"")
			end
		end
	end
end

local function rebootAllComps()
	local normalCursorY = #compNames + 7
	term.setCursorPos(1,normalCursorY)
	oldLoadBarChar = loadBarChar
	loadBarChar = "R"
	loadAnimaion()
	getCompNames()
	for a = 1, #compNames do
		local c = peripheral.wrap(compNames[a])
		if c ~= nil then
			c.reboot()
		end
	end
	printCompNames()
	sleep(0.1)
	loadBarChar = oldLoadBarChar
	loadAnimaion()
end

local function checkForComps() --Checks to see if there are any new computers, based on the compNames table.
	while true do
		oldCompNames = compNames
		getCompNames()
		turnCompsOn()
		if textutils.serialize(compNames) ~= textutils.serialize(oldCompNames) then
			if background == false then
				printCompNames()
				oldnames = names
			end
		end
		sleep(0.15)
	end
end

local function keyPress()
	if startupProg then
		background = true
		term.clear()
		term.setCursorPos(1,1)
		shell.run(startupProg)
		background = false
		getConfig()
		printCompNames()
		turnCompsOn()
		startupProg = nil
	end
	if background then
		background = true
		term.clear()
		term.setCursorPos(1,1)
		shell.run("/rom/programs/shell")
		background = false
		getConfig()
		printCompNames()
		turnCompsOn()
	end
	while true do
		local event, key = os.pullEvent("char")
		if key == "r" then
			rebootAllComps()
		end
		if key == "x" then
			term.setBackgroundColor(colors.black)
			--term.setTextColor(1)
			background = true
			printCompNames()
			return
		end
		if key == "b" then
			background = true
			term.setTextColor(colors.white)
			term.setBackgroundColor(colors.black)
			term.clear()
			term.setCursorPos(1,1)
			shell.run("/rom/programs/shell")
			background = false
			getConfig()
			printCompNames()
			turnCompsOn()
		end
	end
end

local function animateSpinLines()
	while true do
		for l = 1, #ani_spinLine do
			if background == false then
				for a = 1, #itemPosXes do
					if itemPosXes[a] ~= nil then
						drawX = (25 * round((itemPosXes[a] + 1) / 25) - 2)
					end
					if itemPosYes[a] ~= nil then
						drawY = itemPosYes[a]
					end
					term.setTextColor(1)
					if drawX <= scr_x and drawY <= scr_y then
						term.setCursorPos(drawX,drawY)
						c = peripheral.wrap(compNames[a])
						if colormode then
							term.setTextColor(1)
						else
							term.setTextColor(colors.black)
						end
						if c ~= nil then
							if c.isOn() then
								itemNumber = l + (drawY + 1)
								if itemNumber > #ani_spinLine then
									repeat
										itemNumber = itemNumber - #ani_spinLine
									until itemNumber <= #ani_spinLine
								end
								write(ani_spinLine[itemNumber])
							else
								write("*")
							end
						end
					end
				end
				getDefaultColors()
			end
			sleep(0.05)
		end
	end
end

local function animateLoadBar()
	while true do
		for l = 1, #ani_loadBar do
			if background == false then
				local drawX = 16 + string.len(#compNames)
				local drawY = 1
				term.setCursorPos(drawX,drawY)
				if colormode then
					term.setTextColor(1)
				else
					term.setTextColor(colors.black)
				end
				write(ani_loadBar[l])
			end
			sleep(0.06)
		end
	end
end

getCompNames()
printCompNames()

if rebootCompsAtStart then
	rebootAllComps()
end

if animations then
	parallel.waitForAny(checkForComps, keyPress, animateSpinLines, animateLoadBar)
else
	parallel.waitForAny(checkForComps, keyPress)
end

normalCursorY = scr_y
term.setCursorPos(1,normalCursorY)
term.setTextColor(1)